# TODO: Include any necessary import statements
from socket import *
from struct import pack, unpack

class BufferedTCPEchoServer(object):
    def __init__(self, host = '', port = 36001, buffer_size = 1024):
        # Save the buffer size to a variable. You'll need this later
        self.buffer_size = buffer_size
        self.client_connected = False
        # This variable is used to tell the server when it should shut down. Our implementation of this server is centered
        # around one or more while loops that keeps the server listening for new connection requests and new messages from
        # a connected client. This should continue forever, or until this self.keep_running is set to False. My testing
        # code will use self.keep_running to shutdown the server for one test case 
        self.keep_running = True

        self.tcp_Server = socket(AF_INET, SOCK_STREAM)
        self.tcp_Server.bind((host, port))

    def findClient(self):
        print('Server: listening...')
        self.tcp_Server.listen(2)
        new_connection, addr = self.tcp_Server.accept()
        print('Server: found client...')
        return new_connection, addr

    def modifyString(self, msg):
        if(len(msg) <= 10):
            return msg
        else:
            msg = msg[10:]
            return msg

    def sendMsg(self, connection, message):
        msg = message.encode()
        msg_length = len(message)
        packed_msg = pack("!I" + str(msg_length) + "s", msg_length, msg)
        connection.send(packed_msg)
        print("Server: Message sent")


    def handleMsg(self, connection):
        FIXED_HEADER_LENGTH = 4
        try:
            print("Server: listening...")
            msg = connection.recv(FIXED_HEADER_LENGTH)
        except ConnectionResetError as e:
            print("Server: Client disconnected")
            self.client_connected = False
            connection.close()
            return

        if(msg):
            print("Server: Message received")
            payload_buffer = b""
            length = unpack('!I', msg)[0] 
            while len(payload_buffer) < length:
                buffer_size = min(self.buffer_size, length - len(payload_buffer))
                data = connection.recv(buffer_size)
                payload_buffer += data 
            message = self.modifyString(payload_buffer.decode())

            if(message == "stop"): ########this can be removed later
                self.keep_running = False
                print("Server: stopping server...")
                return
            self.sendMsg(connection, message)
        else:
            print("Server: Client forced disconnect")
            self.client_connected = False
            connection.close()
            return


    # This function starts the server listening for new connections and new messages. It initiates the core loop of our 
    # server, where we loop continuously listening for a new connection, or if we are already connected, listening for a new 
    # message. I recommend breaking the functionality up into helper functions
    # Remember that this server can only talk to one connected client at a time. We'll implement a server that
    # can connect to multiple clients at once in a future project.
    # TODO: * Listen for new connections
    #       * Accept new connections
    #       * Receive messages from the connected client until it disconnects. 
    #           * Be sure to set the bufsize parameter to self.buffer_size when calling the socket's receive function
    #       * When a message is received, remove the first ten characters and then send it back to the client. 
    #           * You can use the slice operator to remove the first 10 characters: shorter_string = my_string_variable[10:] 
    #           * You will need to package the message using the format discussed in the assignment instructions
    #       * On disconnect, attempt to accept a new connection
    #       * This process should continue until self.keep_running is set to False. (The program doesn't need immediately close when the value changes)
    #       * Shutdown the server's socket before exiting the program
    def start(self):
        while(self.keep_running == True):
            new_connection, arr = self.findClient()
            self.client_connected = True
            while(self.client_connected == True and self.keep_running == True):
                self.handleMsg(new_connection)
        self.shutdown(new_connection)

        


    # This method is called by the autograder when it is ready to shut down your program. You should clean up your server socket
    # here. Note that all other sockets opened by the server also need to be closed once you are done with them. You should be closing
    # the individual client sockets generated by socket.accept() inside of your start() function 
    # TODO: Clean up your server socket
    def shutdown(self, connection):
        print("SERVER: shutting down...")
        connection.close()
        self.tcp_Server.close()


if __name__ == "__main__":
    BufferedTCPEchoServer(host='', port=36001, buffer_size=1024).start()
    